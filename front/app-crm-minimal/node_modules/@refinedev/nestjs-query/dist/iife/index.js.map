{"version":3,"sources":["../../src/dataProvider/index.ts","../../src/utils/index.ts","../../src/index.ts","../../../../node_modules/graphql-request/src/index.ts","../../src/liveProvider/index.ts"],"sourcesContent":["import {\n    BaseKey,\n    BaseRecord,\n    DataProvider,\n    GetManyResponse,\n    LogicalFilter,\n    MetaQuery,\n} from \"@refinedev/core\";\nimport camelcase from \"camelcase\";\nimport * as gql from \"gql-query-builder\";\nimport VariableOptions from \"gql-query-builder/build/VariableOptions\";\nimport { GraphQLClient } from \"graphql-request\";\nimport { singular } from \"pluralize\";\nimport { generatePaging, generateFilters, generateSorting } from \"../utils\";\n\nconst handleGetMany = async <TData>(\n    client: GraphQLClient,\n    {\n        resource,\n        ids,\n        meta,\n    }: { resource: string; ids: BaseKey[]; meta?: MetaQuery },\n): Promise<GetManyResponse<TData>> => {\n    const operation = camelcase(resource);\n\n    const { query, variables } = gql.query({\n        operation,\n        fields: [{ nodes: meta?.fields || [\"id\"] }],\n        variables: {\n            filter: {\n                type: camelcase(`${singular(resource)}Filter`, {\n                    pascalCase: true,\n                }),\n                required: true,\n                value: {\n                    id: { in: ids },\n                },\n            },\n        },\n    });\n\n    const response = await client.request<BaseRecord>(query, variables);\n\n    return {\n        data: response[operation].nodes,\n    };\n};\n\nconst dataProvider = (client: GraphQLClient): Required<DataProvider> => {\n    return {\n        getList: async ({ resource, pagination, sorters, filters, meta }) => {\n            const operation = camelcase(resource);\n\n            const paging = generatePaging(pagination || {});\n\n            const queryVariables: VariableOptions = {};\n\n            if (filters) {\n                queryVariables[\"filter\"] = {\n                    type: camelcase(`${singular(resource)}Filter`, {\n                        pascalCase: true,\n                    }),\n                    required: true,\n                    value: generateFilters(filters as LogicalFilter[]),\n                };\n            }\n\n            if (sorters) {\n                queryVariables[\"sorting\"] = {\n                    type: camelcase(`${singular(resource)}Sort`, {\n                        pascalCase: true,\n                    }),\n                    required: true,\n                    list: [true],\n                    value: generateSorting(sorters),\n                };\n            }\n\n            if (paging) {\n                queryVariables[\"paging\"] = {\n                    type: \"OffsetPaging\",\n                    required: true,\n                    value: paging,\n                };\n            }\n\n            const { query, variables } = gql.query({\n                operation,\n                fields: [{ nodes: meta?.fields }, \"totalCount\"],\n                variables: queryVariables,\n            });\n\n            const response = await client.request<BaseRecord>(query, variables);\n\n            return {\n                data: response[operation].nodes,\n                total: response[operation].totalCount,\n            };\n        },\n\n        getMany: async ({ resource, ids, meta }) => {\n            return await handleGetMany(client, { resource, ids, meta });\n        },\n\n        create: async ({ resource, variables, meta }) => {\n            const operation = `createOne${camelcase(singular(resource), {\n                pascalCase: true,\n            })}`;\n\n            const { query, variables: queryVariables } = gql.mutation({\n                operation,\n                fields: meta?.fields || [\"id\"],\n                variables: {\n                    input: {\n                        type: `CreateOne${camelcase(singular(resource), {\n                            pascalCase: true,\n                        })}Input`,\n                        required: true,\n                        value: {\n                            [camelcase(singular(resource))]: variables,\n                        },\n                    },\n                },\n            });\n\n            const response = await client.request<BaseRecord>(\n                query,\n                queryVariables,\n            );\n\n            return {\n                data: response[operation],\n            };\n        },\n\n        createMany: async ({ resource, variables, meta }) => {\n            const operation = `createMany${camelcase(resource, {\n                pascalCase: true,\n            })}`;\n\n            const { query, variables: queryVariables } = gql.mutation({\n                operation,\n                fields: meta?.fields || [\"id\"],\n                variables: {\n                    input: {\n                        type: `CreateMany${camelcase(resource, {\n                            pascalCase: true,\n                        })}Input`,\n                        required: true,\n                        value: {\n                            [camelcase(resource)]: variables,\n                        },\n                    },\n                },\n            });\n\n            const response = await client.request<BaseRecord>(\n                query,\n                queryVariables,\n            );\n\n            return {\n                data: response[operation],\n            };\n        },\n        update: async ({ resource, id, variables, meta }) => {\n            const operation = `updateOne${camelcase(singular(resource), {\n                pascalCase: true,\n            })}`;\n\n            const { query, variables: queryVariables } = gql.mutation({\n                operation,\n                fields: meta?.fields || [\"id\"],\n                variables: {\n                    input: {\n                        type: `UpdateOne${camelcase(singular(resource), {\n                            pascalCase: true,\n                        })}Input`,\n                        required: true,\n                        value: {\n                            id,\n                            update: variables,\n                        },\n                    },\n                },\n            });\n\n            const response = await client.request<BaseRecord>(\n                query,\n                queryVariables,\n            );\n\n            return {\n                data: response[operation],\n            };\n        },\n\n        updateMany: async ({ resource, ids, variables, meta }) => {\n            const operation = `updateMany${camelcase(resource, {\n                pascalCase: true,\n            })}`;\n\n            const { query, variables: queryVariables } = gql.mutation({\n                operation,\n                fields: [\"updatedCount\"],\n                variables: {\n                    input: {\n                        type: `UpdateMany${camelcase(resource, {\n                            pascalCase: true,\n                        })}Input`,\n                        required: true,\n                        value: {\n                            filter: {\n                                id: { in: ids },\n                            },\n                            update: variables,\n                        },\n                    },\n                },\n            });\n\n            await client.request<BaseRecord>(query, queryVariables);\n\n            return await handleGetMany(client, { resource, ids, meta });\n        },\n        getOne: async ({ resource, id, meta }) => {\n            const operation = camelcase(singular(resource));\n\n            const { query, variables } = gql.query({\n                operation,\n                fields: meta?.fields || [\"id\"],\n                variables: {\n                    id: {\n                        type: \"ID\",\n                        required: true,\n                        value: id,\n                    },\n                },\n            });\n\n            const response = await client.request<BaseRecord>(query, variables);\n\n            return {\n                data: response[operation],\n            };\n        },\n        deleteOne: async ({ resource, id, meta }) => {\n            const operation = `deleteOne${camelcase(singular(resource), {\n                pascalCase: true,\n            })}`;\n\n            const { query, variables } = gql.mutation({\n                operation,\n                fields: meta?.fields || [\"id\"],\n                variables: {\n                    input: {\n                        type: `DeleteOne${camelcase(singular(resource), {\n                            pascalCase: true,\n                        })}Input`,\n                        required: true,\n                        value: {\n                            id,\n                        },\n                    },\n                },\n            });\n\n            const response = await client.request<BaseRecord>(query, variables);\n\n            return {\n                data: response[operation],\n            };\n        },\n        deleteMany: async ({ resource, ids, meta }) => {\n            const operation = `deleteMany${camelcase(resource, {\n                pascalCase: true,\n            })}`;\n\n            const { query, variables } = gql.mutation({\n                operation,\n                fields: [\"deletedCount\"],\n                variables: {\n                    input: {\n                        type: `DeleteMany${camelcase(resource, {\n                            pascalCase: true,\n                        })}Input`,\n                        required: true,\n                        value: {\n                            filter: {\n                                id: { in: ids },\n                            },\n                        },\n                    },\n                },\n            });\n\n            await client.request<BaseRecord>(query, variables);\n\n            return {\n                data: [],\n            };\n        },\n        getApiUrl: () => {\n            throw Error(\n                \"Not implemented on refine-nestjs-query data provider.\",\n            );\n        },\n        custom: async ({ url, method, headers, meta }) => {\n            if (url) {\n                client.setEndpoint(url);\n            }\n            client.setHeaders(headers);\n\n            if (meta?.rawQuery) {\n                const response = await client.request<BaseRecord>(\n                    meta.rawQuery,\n                    meta.variables,\n                );\n\n                return { data: response };\n            }\n\n            if (meta) {\n                if (meta.operation) {\n                    if (method === \"get\") {\n                        const { query, variables } = gql.query({\n                            operation: meta.operation,\n                            fields: meta.fields,\n                            variables: meta.variables,\n                        });\n\n                        const response = await client.request<BaseRecord>(\n                            query,\n                            variables,\n                        );\n\n                        return {\n                            data: response[meta.operation],\n                        };\n                    } else {\n                        const { query, variables } = gql.mutation({\n                            operation: meta.operation,\n                            fields: meta.fields,\n                            variables: meta.variables,\n                        });\n\n                        const response = await client.request<BaseRecord>(\n                            query,\n                            variables,\n                        );\n\n                        return {\n                            data: response[meta.operation],\n                        };\n                    }\n                } else {\n                    throw Error(\"GraphQL operation name required.\");\n                }\n            } else {\n                throw Error(\n                    \"GraphQL needs operation, fields and variables values in meta object.\",\n                );\n            }\n        },\n    };\n};\n\nexport default dataProvider;\n","import {\n    CrudOperators,\n    LogicalFilter,\n    CrudSorting,\n    Pagination,\n    CrudFilter,\n} from \"@refinedev/core\";\nimport camelcase from \"camelcase\";\nimport VariableOptions from \"gql-query-builder/build/VariableOptions\";\nimport * as gql from \"gql-query-builder\";\nimport { singular } from \"pluralize\";\nimport set from \"lodash/set\";\n\nconst operatorMap: { [key: string]: string } = {\n    eq: \"eq\",\n    ne: \"neq\",\n    lt: \"lt\",\n    gt: \"gt\",\n    lte: \"lte\",\n    gte: \"gte\",\n    in: \"in\",\n    nin: \"notIn\",\n};\n\nconst operatorMapper = (\n    operator: CrudOperators,\n    value: any,\n): { [key: string]: any } => {\n    if (operator === \"contains\") {\n        return { iLike: `%${value}%` };\n    }\n\n    if (operator === \"ncontains\") {\n        return { notILike: `%${value}%` };\n    }\n\n    if (operator === \"startswith\") {\n        return { iLike: `${value}%` };\n    }\n\n    if (operator === \"nstartswith\") {\n        return { notILike: `${value}%` };\n    }\n\n    if (operator === \"endswith\") {\n        return { iLike: `%${value}` };\n    }\n\n    if (operator === \"nendswith\") {\n        return { notILike: `%${value}` };\n    }\n\n    if (operator === \"null\") {\n        return { is: null };\n    }\n\n    if (operator === \"nnull\") {\n        return { isNot: null };\n    }\n\n    if (operator === \"between\") {\n        if (!Array.isArray(value)) {\n            throw new Error(\"Between operator requires an array\");\n        }\n\n        if (value.length !== 2) {\n            return {};\n        }\n\n        return { between: { lower: value[0], upper: value[1] } };\n    }\n\n    return { [operatorMap[operator]]: value };\n};\n\nexport const generateFilters = (filters: LogicalFilter[]) => {\n    const result: { [key: string]: { [key: string]: string | number } } = {};\n\n    filters\n        .filter((f) => {\n            if (Array.isArray(f.value) && f.value.length === 0) {\n                return false;\n            }\n\n            return !!f.value;\n        })\n        .map((filter: LogicalFilter | CrudFilter) => {\n            if (filter.operator === \"and\" || filter.operator === \"or\") {\n                return set(result, filter.operator, [\n                    generateFilters(filter.value as LogicalFilter[]),\n                ]);\n            } else if (\"field\" in filter) {\n                return set(\n                    result,\n                    filter.field,\n                    operatorMapper(filter.operator, filter.value),\n                );\n            } else {\n                return {};\n            }\n        });\n\n    return result;\n};\n\nexport const generateSorting = (sorters: CrudSorting) => {\n    return sorters.map((sorter) => {\n        return {\n            field: sorter.field,\n            direction: sorter.order.toUpperCase(),\n        };\n    });\n};\n\nexport const generatePaging = (pagination: Pagination) => {\n    // maximum value of 32 bit signed integer\n    if (pagination.mode === \"off\") return { limit: 2147483647 };\n\n    if (pagination.mode !== \"server\") return undefined;\n\n    if (!pagination.current || !pagination.pageSize) return undefined;\n\n    return {\n        limit: pagination.pageSize,\n        offset: (pagination.current - 1) * pagination.pageSize,\n    };\n};\n\nexport const generateCreatedSubscription = ({\n    resource,\n    filters,\n    meta,\n}: any) => {\n    const operation = `created${camelcase(singular(resource), {\n        pascalCase: true,\n    })}`;\n\n    const queryVariables: VariableOptions = {};\n\n    if (filters) {\n        queryVariables[\"input\"] = {\n            type: camelcase(\n                `create_${singular(resource)}_subscription_filter_input`,\n                {\n                    pascalCase: true,\n                },\n            ),\n            required: true,\n            value: {\n                filter: generateFilters(\n                    filters.filter(\n                        (filter: LogicalFilter) => !filter.field.includes(\".\"),\n                    ),\n                ),\n            },\n        };\n    }\n\n    const { query, variables } = gql.subscription({\n        operation,\n        fields: meta.fields,\n        variables: queryVariables,\n    });\n\n    return { query, variables, operation };\n};\n\nexport const generateUpdatedSubscription = ({\n    resource,\n    filters,\n    meta,\n}: any) => {\n    const operation = `updatedOne${camelcase(singular(resource), {\n        pascalCase: true,\n    })}`;\n\n    const queryVariables: VariableOptions = {};\n\n    if (filters) {\n        queryVariables[\"input\"] = {\n            type: camelcase(\n                `update_one_${singular(resource)}_subscription_filter_input`,\n                {\n                    pascalCase: true,\n                },\n            ),\n            required: true,\n            value: {\n                filter: generateFilters(\n                    filters.filter(\n                        (filter: LogicalFilter) => !filter.field.includes(\".\"),\n                    ),\n                ),\n            },\n        };\n    }\n\n    const { query, variables } = gql.subscription({\n        operation,\n        fields: meta.fields,\n        variables: queryVariables,\n    });\n\n    return { query, variables, operation };\n};\n\nexport const generateDeletedSubscription = ({\n    resource,\n    filters,\n    meta,\n}: any) => {\n    const operation = `deletedOne${camelcase(singular(resource), {\n        pascalCase: true,\n    })}`;\n\n    const queryVariables: VariableOptions = {};\n\n    if (filters) {\n        queryVariables[\"input\"] = {\n            type: camelcase(\n                `delete_one_${singular(resource)}_subscription_filter_input`,\n                {\n                    pascalCase: true,\n                },\n            ),\n            required: true,\n            value: {\n                filter: generateFilters(\n                    filters.filter(\n                        (filter: LogicalFilter) => !filter.field.includes(\".\"),\n                    ),\n                ),\n            },\n        };\n    }\n\n    const { query, variables } = gql.subscription({\n        operation,\n        fields: meta.fields.filter(\n            (field: string | object) => typeof field !== \"object\",\n        ),\n        variables: queryVariables,\n    });\n\n    return { query, variables, operation };\n};\n","import dataProvider from \"./dataProvider\";\nexport default dataProvider;\n\nexport * as qqlQueryBuilder from \"gql-query-builder\";\nexport {\n    batchRequests,\n    gql,\n    GraphQLClient,\n    rawRequest,\n    request,\n    resolveRequestDocument,\n} from \"graphql-request\";\nexport type {\n    BatchRequestDocument,\n    BatchRequestsExtendedOptions,\n    BatchRequestsOptions,\n    ClientError,\n    GraphQLWebSocketClient,\n    RawRequestExtendedOptions,\n    RawRequestOptions,\n    RequestDocument,\n    RequestExtendedOptions,\n    RequestOptions,\n    Variables,\n} from \"graphql-request\";\nexport * as graphqlWS from \"graphql-ws\";\nexport * from \"./dataProvider\";\nexport * from \"./liveProvider\";\n","import createRequestBody from './createRequestBody.js'\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js'\nimport { HeadersInstanceToPlainObject, uppercase } from './helpers.js'\nimport {\n  parseBatchRequestArgs,\n  parseRawRequestArgs,\n  parseRawRequestExtendedArgs,\n  parseRequestArgs,\n  parseRequestExtendedArgs,\n} from './parseArgs.js'\nimport { resolveRequestDocument } from './resolveRequestDocument.js'\nimport type * as Dom from './types.dom.js'\nimport type {\n  HTTPMethodInput,\n  MaybeFunction,\n  RequestConfig,\n  RequestMiddleware,\n  Response,\n  VariablesAndRequestHeadersArgs,\n} from './types.js'\nimport {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n} from './types.js'\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport crossFetch, * as CrossFetch from 'cross-fetch'\nimport type { T, V } from 'vitest/dist/types-7cd96283.js'\n\nexport {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n}\n\n/**\n * Convert the given headers configuration into a plain object.\n */\nconst resolveHeaders = (headers: Dom.RequestInit['headers']): Record<string, string> => {\n  let oHeaders: Record<string, string> = {}\n  if (headers) {\n    if (\n      (typeof Headers !== `undefined` && headers instanceof Headers) ||\n      (CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers)\n    ) {\n      oHeaders = HeadersInstanceToPlainObject(headers)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(([name, value]) => {\n        if (name && value !== undefined) {\n          oHeaders[name] = value\n        }\n      })\n    } else {\n      oHeaders = headers as Record<string, string>\n    }\n  }\n\n  return oHeaders\n}\n\n/**\n * Clean a GraphQL document to send it via a GET query\n */\nconst cleanQuery = (str: string): string => str.replace(/([\\s,]|#[^\\n\\r]+)+/g, ` `).trim()\n\ntype BuildRequestConfigParamsBatch<V> = {\n  query: string[]\n  variables: V[] | undefined\n  operationName: undefined\n  jsonSerializer: Dom.JsonSerializer\n}\n\ntype BuildRequestConfigParamsSingle<V> = {\n  query: string\n  variables: V | undefined\n  operationName: string | undefined\n  jsonSerializer: Dom.JsonSerializer\n}\n\ntype BuildRequestConfigParams<V> = BuildRequestConfigParamsSingle<V> | BuildRequestConfigParamsBatch<V>\n\n/**\n * Create query string for GraphQL request\n */\nconst buildRequestConfig = <V extends Variables>(params: BuildRequestConfigParams<V>): string => {\n  if (!Array.isArray(params.query)) {\n    const params_ = params as BuildRequestConfigParamsSingle<V>\n    const search: string[] = [`query=${encodeURIComponent(cleanQuery(params_.query))}`]\n\n    if (params.variables) {\n      search.push(`variables=${encodeURIComponent(params_.jsonSerializer.stringify(params_.variables))}`)\n    }\n\n    if (params_.operationName) {\n      search.push(`operationName=${encodeURIComponent(params_.operationName)}`)\n    }\n\n    return search.join(`&`)\n  }\n\n  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {\n    throw new Error(`Cannot create query with given variable type, array expected`)\n  }\n\n  // Batch support\n  const params_ = params as BuildRequestConfigParamsBatch<V>\n  const payload = params.query.reduce<{ query: string; variables: string | undefined }[]>(\n    (acc, currentQuery, index) => {\n      acc.push({\n        query: cleanQuery(currentQuery),\n        variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : undefined,\n      })\n      return acc\n    },\n    []\n  )\n\n  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`\n}\n\ntype Fetch = (url: string, config: Dom.RequestInit) => Promise<Dom.Response>\n\ninterface RequestVerbParams<V extends Variables = Variables> {\n  url: string\n  query: string | string[]\n  fetch: Fetch\n  fetchOptions: Dom.RequestInit\n  variables?: V\n  headers?: Dom.RequestInit['headers']\n  operationName?: string\n  middleware?: RequestMiddleware<V>\n}\n\nconst createHttpMethodFetcher =\n  (method: 'GET' | 'POST') =>\n  async <V extends Variables>(params: RequestVerbParams<V>) => {\n    const { url, query, variables, operationName, fetch, fetchOptions, middleware } = params\n\n    const headers = { ...params.headers }\n    let queryParams = ``\n    let body = undefined\n\n    if (method === `POST`) {\n      body = createRequestBody(query, variables, operationName, fetchOptions.jsonSerializer)\n      if (typeof body === `string`) {\n        // @ts-expect-error todo\n        headers[`Content-Type`] = `application/json`\n      }\n    } else {\n      // @ts-expect-error todo needs ADT for TS to understand the different states\n      queryParams = buildRequestConfig<V>({\n        query,\n        variables,\n        operationName,\n        jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer,\n      })\n    }\n\n    const init: Dom.RequestInit = {\n      method,\n      headers,\n      body,\n      ...fetchOptions,\n    }\n\n    let urlResolved = url\n    let initResolved = init\n    if (middleware) {\n      const result = await Promise.resolve(middleware({ ...init, url, operationName, variables }))\n      const { url: urlNew, ...initNew } = result\n      urlResolved = urlNew\n      initResolved = initNew\n    }\n    if (queryParams) {\n      urlResolved = `${urlResolved}?${queryParams}`\n    }\n    return await fetch(urlResolved, initResolved)\n  }\n\n/**\n * GraphQL Client.\n */\nexport class GraphQLClient {\n  constructor(private url: string, public readonly requestConfig: RequestConfig = {}) {}\n\n  /**\n   * Send a GraphQL query to the server.\n   */\n  rawRequest: RawRequestMethod = async <T, V extends Variables = Variables>(\n    ...args: RawRequestMethodArgs<V>\n  ): Promise<Response<T>> => {\n    const [queryOrOptions, variables, requestHeaders] = args\n    const rawRequestOptions = parseRawRequestArgs<V>(queryOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (rawRequestOptions.signal !== undefined) {\n      fetchOptions.signal = rawRequestOptions.signal\n    }\n\n    const { operationName } = resolveRequestDocument(rawRequestOptions.query)\n\n    return makeRequest<T, V>({\n      url,\n      query: rawRequestOptions.query,\n      variables: rawRequestOptions.variables as V,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(rawRequestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send a GraphQL document to the server.\n   */\n  async request<T, V extends Variables = Variables>(\n    document: RequestDocument | TypedDocumentNode<T, V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T>\n  async request<T, V extends Variables = Variables>(options: RequestOptions<V, T>): Promise<T>\n  async request<T, V extends Variables = Variables>(\n    documentOrOptions: RequestDocument | TypedDocumentNode<T, V> | RequestOptions<V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T> {\n    const [variables, requestHeaders] = variablesAndRequestHeaders\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal\n    }\n\n    const { query, operationName } = resolveRequestDocument(requestOptions.document)\n\n    return makeRequest<T>({\n      url,\n      query,\n      variables: requestOptions.variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(requestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send GraphQL documents in batch to the server.\n   */\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(documents: BatchRequestDocument<V>[], requestHeaders?: Dom.RequestInit['headers']): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsOptions<V>): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(\n    documentsOrOptions: BatchRequestDocument<V>[] | BatchRequestsOptions<V>,\n    requestHeaders?: Dom.RequestInit['headers']\n  ): Promise<T> {\n    const batchRequestOptions = parseBatchRequestArgs<V>(documentsOrOptions, requestHeaders)\n    const { headers, ...fetchOptions } = this.requestConfig\n\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal\n    }\n\n    const queries = batchRequestOptions.documents.map(\n      ({ document }) => resolveRequestDocument(document).query\n    )\n    const variables = batchRequestOptions.documents.map(({ variables }) => variables)\n\n    return makeRequest<T>({\n      url: this.url,\n      query: queries,\n      // @ts-expect-error TODO reconcile batch variables into system.\n      variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(batchRequestOptions.requestHeaders),\n      },\n      operationName: undefined,\n      fetch: this.requestConfig.fetch ?? crossFetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware,\n    })\n      .then((response) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  setHeaders(headers: Dom.RequestInit['headers']): GraphQLClient {\n    this.requestConfig.headers = headers\n    return this\n  }\n\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key: string, value: string): GraphQLClient {\n    const { headers } = this.requestConfig\n\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      //@ts-ignore\n      headers[key] = value\n    } else {\n      this.requestConfig.headers = { [key]: value }\n    }\n\n    return this\n  }\n\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value: string): GraphQLClient {\n    this.url = value\n    return this\n  }\n}\n\nconst makeRequest = async <T = unknown, V extends Variables = Variables>(params: {\n  url: string\n  query: string | string[]\n  variables?: V\n  headers?: Dom.RequestInit['headers']\n  operationName?: string\n  fetch: Fetch\n  method?: HTTPMethodInput\n  fetchOptions: Dom.RequestInit\n  middleware?: RequestMiddleware<V>\n}): Promise<Response<T>> => {\n  const { query, variables, fetchOptions } = params\n  const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`))\n  const isBatchingQuery = Array.isArray(params.query)\n  const response = await fetcher(params)\n  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer)\n\n  const successfullyReceivedData = Array.isArray(result)\n    ? !result.some(({ data }) => !data)\n    : Boolean(result.data)\n\n  const successfullyPassedErrorPolicy =\n    Array.isArray(result) ||\n    !result.errors ||\n    (Array.isArray(result.errors) && !result.errors.length) ||\n    fetchOptions.errorPolicy === `all` ||\n    fetchOptions.errorPolicy === `ignore`\n\n  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {\n    // @ts-expect-error TODO fixme\n    const { errors, ...rest } = Array.isArray(result) ? result : result\n    const data = fetchOptions.errorPolicy === `ignore` ? rest : result\n    const dataEnvelope = isBatchingQuery ? { data } : data\n\n    // @ts-expect-error TODO\n    return {\n      ...dataEnvelope,\n      headers: response.headers,\n      status: response.status,\n    }\n  } else {\n    const errorResult =\n      typeof result === `string`\n        ? {\n            error: result,\n          }\n        : result\n    throw new ClientError(\n      // @ts-expect-error TODO\n      { ...errorResult, status: response.status, headers: response.headers },\n      { query, variables }\n    )\n  }\n}\n\n// prettier-ignore\ninterface RawRequestMethod {\n  <T, V extends Variables = Variables>(query: string, variables?: V, requestHeaders?: Dom.RequestInit['headers']): Promise<Response<T>>\n  <T, V extends Variables = Variables>(options: RawRequestOptions<V>): Promise<Response<T>>\n}\n\n// prettier-ignore\ntype RawRequestMethodArgs<V extends Variables> =\n  | [query: string, variables?: V, requestHeaders?: Dom.RequestInit['headers']]\n  | [RawRequestOptions<V>]\n\n// prettier-ignore\ninterface RawRequest {\n  <T, V extends Variables = Variables>(url: string, query: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<Response<T>>\n  <T, V extends Variables = Variables>(options: RawRequestExtendedOptions<V>): Promise<Response<T>>\n}\n\n// prettier-ignore\ntype RawRequestArgs<V extends Variables> = \n  | [options: RawRequestExtendedOptions<V>, query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n  | [url: string,                           query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n\n/**\n * Send a GraphQL Query to the GraphQL server for execution.\n */\nexport const rawRequest: RawRequest = async <T, V extends Variables>(\n  ...args: RawRequestArgs<V>\n): Promise<Response<T>> => {\n  const [urlOrOptions, query, ...variablesAndRequestHeaders] = args\n  const requestOptions = parseRawRequestExtendedArgs<V>(urlOrOptions, query, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.rawRequest<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await request('https://foo.bar/graphql', `\n *   {\n *     query {\n *       users\n *     }\n *   }\n * `)\n *\n * // You can also pass a GraphQL DocumentNode. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * // If you don't actually care about using DocumentNode but just\n * // want the tooling support for gql template tag like IDE syntax\n * // coloring and prettier autoformat then note you can use the\n * // passthrough gql tag shipped with graphql-request to save a bit\n * // of performance and not have to install another dep into your project.\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n */\nexport async function request<T, V extends Variables = Variables>(\n  url: string,\n  // @ts-ignore\n  document: RequestDocument | TypedDocumentNode<T, V>,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): Promise<T>\nexport async function request<T, V extends Variables = Variables>(\n  options: RequestExtendedOptions<V, T>\n): Promise<T>\nexport async function request<T, V extends Variables = Variables>(\n  urlOrOptions: string | RequestExtendedOptions<V, T>,\n  // @ts-ignore\n  document?: RequestDocument | TypedDocumentNode<T, V>,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): Promise<T> {\n  // @ts-ignore\n  const requestOptions = parseRequestExtendedArgs<V>(urlOrOptions, document, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.request<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a batch of GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await batchRequests('https://foo.bar/graphql', [\n * {\n *  query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * },\n * {\n *   query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * }])\n *\n * // You can also pass a GraphQL DocumentNode as query. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await batchRequests('https://foo.bar/graphql', [{ query: gql`...` }])\n * ```\n */\nexport const batchRequests: BatchRequests = async (...args: BatchRequestsArgs) => {\n  const params = parseBatchRequestsArgsExtended(args)\n  const client = new GraphQLClient(params.url)\n  return client.batchRequests(params)\n}\n\ninterface Result<Data extends object = object> {\n  data: Data\n}\n\ntype BatchResult = [Result, ...Result[]]\n\n// prettier-ignore\ninterface BatchRequests {\n  <T extends BatchResult, V extends Variables = Variables>(url: string, documents: BatchRequestDocument<V>[], requestHeaders?: Dom.RequestInit['headers']): Promise<T>\n  <T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsExtendedOptions<V>): Promise<T>\n}\n\ntype BatchRequestsArgs =\n  | [url: string, documents: BatchRequestDocument[], requestHeaders?: Dom.RequestInit['headers']]\n  | [options: BatchRequestsExtendedOptions]\n\nconst parseBatchRequestsArgsExtended = (args: BatchRequestsArgs): BatchRequestsExtendedOptions => {\n  if (args.length === 1) {\n    return args[0]\n  } else {\n    return {\n      url: args[0],\n      documents: args[1],\n      requestHeaders: args[2],\n      signal: undefined,\n    }\n  }\n}\n\nexport default request\n\nconst getResult = async (\n  response: Dom.Response,\n  jsonSerializer: Dom.JsonSerializer\n): Promise<\n  | { data: object; errors: undefined }[]\n  | { data: object; errors: undefined }\n  | { data: undefined; errors: object }\n  | { data: undefined; errors: object[] }\n> => {\n  let contentType: string | undefined\n\n  response.headers.forEach((value, key) => {\n    if (key.toLowerCase() === `content-type`) {\n      contentType = value\n    }\n  })\n\n  if (\n    contentType &&\n    (contentType.toLowerCase().startsWith(`application/json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql+json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql-response+json`))\n  ) {\n    return jsonSerializer.parse(await response.text()) as any\n  } else {\n    return response.text() as any\n  }\n}\n\nconst callOrIdentity = <T>(value: MaybeFunction<T>) => {\n  return typeof value === `function` ? (value as () => T)() : value\n}\n\n/**\n * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.\n *\n * @example\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * @remarks\n *\n * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named \"gql\". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.\n */\nexport const gql = (chunks: TemplateStringsArray, ...variables: any[]): string => {\n  return chunks.reduce(\n    (accumulator, chunk, index) => `${accumulator}${chunk}${index in variables ? variables[index] : ``}`,\n    ``\n  )\n}\n\nexport { GraphQLWebSocketClient } from './graphql-ws.js'\nexport { resolveRequestDocument } from './resolveRequestDocument.js'\n","import { LiveProvider } from \"@refinedev/core\";\nimport { Client } from \"graphql-ws\";\nimport {\n    generateCreatedSubscription,\n    generateDeletedSubscription,\n    generateUpdatedSubscription,\n} from \"../utils\";\n\nconst generateSubscription = (\n    client: Client,\n    { callback, params }: any,\n    type: string,\n) => {\n    const generatorMap: any = {\n        created: generateCreatedSubscription,\n        updated: generateUpdatedSubscription,\n        deleted: generateDeletedSubscription,\n    };\n\n    const { resource, meta, filters, subscriptionType, id, ids } = params ?? {};\n\n    const generator = generatorMap[type];\n\n    const { operation, query, variables } = generator({\n        ids,\n        id,\n        resource,\n        filters,\n        meta,\n        subscriptionType,\n    });\n\n    const onNext = (payload: any) => {\n        callback(payload.data[operation]);\n    };\n\n    const unsubscribe = client.subscribe(\n        { query, variables },\n        {\n            next: onNext,\n            error: console.error,\n            complete: () => null,\n        },\n    );\n\n    return unsubscribe;\n};\n\nexport const liveProvider = (client: Client): LiveProvider => {\n    return {\n        subscribe({ callback, params }) {\n            const { resource, meta, filters, subscriptionType, id, ids } =\n                params ?? {};\n\n            if (!meta) {\n                throw new Error(\n                    \"[useSubscription]: `meta` is required in `params` for graphql subscriptions\",\n                );\n            }\n\n            if (!subscriptionType) {\n                throw new Error(\n                    \"[useSubscription]: `subscriptionType` is required in `params` for graphql subscriptions\",\n                );\n            }\n\n            if (!resource) {\n                throw new Error(\n                    \"[useSubscription]: `resource` is required in `params` for graphql subscriptions\",\n                );\n            }\n\n            const unsubscribes: any[] = [];\n\n            if (params?.subscriptionType === \"useList\") {\n                const createdUnsubscribe = generateSubscription(\n                    client,\n                    { callback, params },\n                    \"created\",\n                );\n\n                const updatedUnsubscribe = generateSubscription(\n                    client,\n                    { callback, params },\n                    \"updated\",\n                );\n\n                const deletedUnsubscribe = generateSubscription(\n                    client,\n                    { callback, params },\n                    \"deleted\",\n                );\n\n                unsubscribes.push(createdUnsubscribe);\n                unsubscribes.push(updatedUnsubscribe);\n                unsubscribes.push(deletedUnsubscribe);\n            }\n\n            if (params?.subscriptionType === \"useOne\") {\n                const updatedUnsubscribe = generateSubscription(\n                    client,\n                    { callback, params },\n                    \"updated\",\n                );\n\n                unsubscribes.push(updatedUnsubscribe);\n            }\n\n            const unsubscribe = () => {\n                unsubscribes.forEach((unsubscribe) => unsubscribe());\n            };\n\n            return unsubscribe;\n        },\n        unsubscribe(unsubscribe) {\n            unsubscribe();\n        },\n    };\n};\n"],"mappings":"ktBAQA,IAAAA,EAAsB,kBACtBC,EAAqB,0BAGrBC,EAAyB,eCLzB,IAAAC,EAAsB,kBAEtBC,EAAqB,0BACrBC,EAAyB,eACzBC,EAAgB,mBAEVC,GAAyC,CAC3C,GAAI,KACJ,GAAI,MACJ,GAAI,KACJ,GAAI,KACJ,IAAK,MACL,IAAK,MACL,GAAI,KACJ,IAAK,OACT,EAEMC,GAAiB,CACnBC,EACAC,IACyB,CACzB,GAAID,IAAa,WACb,MAAO,CAAE,MAAO,IAAIC,IAAS,EAGjC,GAAID,IAAa,YACb,MAAO,CAAE,SAAU,IAAIC,IAAS,EAGpC,GAAID,IAAa,aACb,MAAO,CAAE,MAAO,GAAGC,IAAS,EAGhC,GAAID,IAAa,cACb,MAAO,CAAE,SAAU,GAAGC,IAAS,EAGnC,GAAID,IAAa,WACb,MAAO,CAAE,MAAO,IAAIC,GAAQ,EAGhC,GAAID,IAAa,YACb,MAAO,CAAE,SAAU,IAAIC,GAAQ,EAGnC,GAAID,IAAa,OACb,MAAO,CAAE,GAAI,IAAK,EAGtB,GAAIA,IAAa,QACb,MAAO,CAAE,MAAO,IAAK,EAGzB,GAAIA,IAAa,UAAW,CACxB,GAAI,CAAC,MAAM,QAAQC,CAAK,EACpB,MAAM,IAAI,MAAM,oCAAoC,EAGxD,OAAIA,EAAM,SAAW,EACV,CAAC,EAGL,CAAE,QAAS,CAAE,MAAOA,EAAM,CAAC,EAAG,MAAOA,EAAM,CAAC,CAAE,CAAE,EAG3D,MAAO,CAAE,CAACH,GAAYE,CAAQ,CAAC,EAAGC,CAAM,CAC5C,EAEaC,EAAmBC,GAA6B,CACzD,IAAMC,EAAgE,CAAC,EAEvE,OAAAD,EACK,OAAQE,GACD,MAAM,QAAQA,EAAE,KAAK,GAAKA,EAAE,MAAM,SAAW,EACtC,GAGJ,CAAC,CAACA,EAAE,KACd,EACA,IAAKC,GACEA,EAAO,WAAa,OAASA,EAAO,WAAa,QAC1C,EAAAC,SAAIH,EAAQE,EAAO,SAAU,CAChCJ,EAAgBI,EAAO,KAAwB,CACnD,CAAC,EACM,UAAWA,KACX,EAAAC,SACHH,EACAE,EAAO,MACPP,GAAeO,EAAO,SAAUA,EAAO,KAAK,CAChD,EAEO,CAAC,CAEf,EAEEF,CACX,EAEaI,EAAmBC,GACrBA,EAAQ,IAAKC,IACT,CACH,MAAOA,EAAO,MACd,UAAWA,EAAO,MAAM,YAAY,CACxC,EACH,EAGQC,EAAkBC,GAA2B,CAEtD,GAAIA,EAAW,OAAS,MAAO,MAAO,CAAE,MAAO,UAAW,EAE1D,GAAIA,EAAW,OAAS,UAEpB,GAACA,EAAW,SAAW,CAACA,EAAW,UAEvC,MAAO,CACH,MAAOA,EAAW,SAClB,QAASA,EAAW,QAAU,GAAKA,EAAW,QAClD,CACJ,EAEaC,EAA8B,CAAC,CACxC,SAAAC,EACA,QAAAX,EACA,KAAAY,CACJ,IAAW,CACP,IAAMC,EAAY,aAAU,EAAAC,YAAU,YAASH,CAAQ,EAAG,CACtD,WAAY,EAChB,CAAC,IAEKI,EAAkC,CAAC,EAErCf,IACAe,EAAe,MAAW,CACtB,QAAM,EAAAD,SACF,aAAU,YAASH,CAAQ,8BAC3B,CACI,WAAY,EAChB,CACJ,EACA,SAAU,GACV,MAAO,CACH,OAAQZ,EACJC,EAAQ,OACHG,GAA0B,CAACA,EAAO,MAAM,SAAS,GAAG,CACzD,CACJ,CACJ,CACJ,GAGJ,GAAM,CAAE,MAAAa,EAAO,UAAAC,CAAU,EAAQ,eAAa,CAC1C,UAAAJ,EACA,OAAQD,EAAK,OACb,UAAWG,CACf,CAAC,EAED,MAAO,CAAE,MAAAC,EAAO,UAAAC,EAAW,UAAAJ,CAAU,CACzC,EAEaK,EAA8B,CAAC,CACxC,SAAAP,EACA,QAAAX,EACA,KAAAY,CACJ,IAAW,CACP,IAAMC,EAAY,gBAAa,EAAAC,YAAU,YAASH,CAAQ,EAAG,CACzD,WAAY,EAChB,CAAC,IAEKI,EAAkC,CAAC,EAErCf,IACAe,EAAe,MAAW,CACtB,QAAM,EAAAD,SACF,iBAAc,YAASH,CAAQ,8BAC/B,CACI,WAAY,EAChB,CACJ,EACA,SAAU,GACV,MAAO,CACH,OAAQZ,EACJC,EAAQ,OACHG,GAA0B,CAACA,EAAO,MAAM,SAAS,GAAG,CACzD,CACJ,CACJ,CACJ,GAGJ,GAAM,CAAE,MAAAa,EAAO,UAAAC,CAAU,EAAQ,eAAa,CAC1C,UAAAJ,EACA,OAAQD,EAAK,OACb,UAAWG,CACf,CAAC,EAED,MAAO,CAAE,MAAAC,EAAO,UAAAC,EAAW,UAAAJ,CAAU,CACzC,EAEaM,EAA8B,CAAC,CACxC,SAAAR,EACA,QAAAX,EACA,KAAAY,CACJ,IAAW,CACP,IAAMC,EAAY,gBAAa,EAAAC,YAAU,YAASH,CAAQ,EAAG,CACzD,WAAY,EAChB,CAAC,IAEKI,EAAkC,CAAC,EAErCf,IACAe,EAAe,MAAW,CACtB,QAAM,EAAAD,SACF,iBAAc,YAASH,CAAQ,8BAC/B,CACI,WAAY,EAChB,CACJ,EACA,SAAU,GACV,MAAO,CACH,OAAQZ,EACJC,EAAQ,OACHG,GAA0B,CAACA,EAAO,MAAM,SAAS,GAAG,CACzD,CACJ,CACJ,CACJ,GAGJ,GAAM,CAAE,MAAAa,EAAO,UAAAC,CAAU,EAAQ,eAAa,CAC1C,UAAAJ,EACA,OAAQD,EAAK,OAAO,OACfQ,GAA2B,OAAOA,GAAU,QACjD,EACA,UAAWL,CACf,CAAC,EAED,MAAO,CAAE,MAAAC,EAAO,UAAAC,EAAW,UAAAJ,CAAU,CACzC,EDtOA,IAAMQ,EAAgB,MAClBC,EACA,CACI,SAAAC,EACA,IAAAC,EACA,KAAAC,CACJ,IACkC,CAClC,IAAMC,KAAY,EAAAC,SAAUJ,CAAQ,EAE9B,CAAE,MAAAK,EAAO,UAAAC,CAAU,EAAQ,QAAM,CACnC,UAAAH,EACA,OAAQ,CAAC,CAAE,OAAOD,GAAA,YAAAA,EAAM,SAAU,CAAC,IAAI,CAAE,CAAC,EAC1C,UAAW,CACP,OAAQ,CACJ,QAAM,EAAAE,SAAU,MAAG,YAASJ,CAAQ,UAAW,CAC3C,WAAY,EAChB,CAAC,EACD,SAAU,GACV,MAAO,CACH,GAAI,CAAE,GAAIC,CAAI,CAClB,CACJ,CACJ,CACJ,CAAC,EAID,MAAO,CACH,MAHa,MAAMF,EAAO,QAAoBM,EAAOC,CAAS,GAG/CH,CAAS,EAAE,KAC9B,CACJ,EAEMI,GAAgBR,IACX,CACH,QAAS,MAAO,CAAE,SAAAC,EAAU,WAAAQ,EAAY,QAAAC,EAAS,QAAAC,EAAS,KAAAR,CAAK,IAAM,CACjE,IAAMC,KAAY,EAAAC,SAAUJ,CAAQ,EAE9BW,EAASC,EAAeJ,GAAc,CAAC,CAAC,EAExCK,EAAkC,CAAC,EAErCH,IACAG,EAAe,OAAY,CACvB,QAAM,EAAAT,SAAU,MAAG,YAASJ,CAAQ,UAAW,CAC3C,WAAY,EAChB,CAAC,EACD,SAAU,GACV,MAAOc,EAAgBJ,CAA0B,CACrD,GAGAD,IACAI,EAAe,QAAa,CACxB,QAAM,EAAAT,SAAU,MAAG,YAASJ,CAAQ,QAAS,CACzC,WAAY,EAChB,CAAC,EACD,SAAU,GACV,KAAM,CAAC,EAAI,EACX,MAAOe,EAAgBN,CAAO,CAClC,GAGAE,IACAE,EAAe,OAAY,CACvB,KAAM,eACN,SAAU,GACV,MAAOF,CACX,GAGJ,GAAM,CAAE,MAAAN,EAAO,UAAAC,CAAU,EAAQ,QAAM,CACnC,UAAAH,EACA,OAAQ,CAAC,CAAE,MAAOD,GAAA,YAAAA,EAAM,MAAO,EAAG,YAAY,EAC9C,UAAWW,CACf,CAAC,EAEKG,EAAW,MAAMjB,EAAO,QAAoBM,EAAOC,CAAS,EAElE,MAAO,CACH,KAAMU,EAASb,CAAS,EAAE,MAC1B,MAAOa,EAASb,CAAS,EAAE,UAC/B,CACJ,EAEA,QAAS,MAAO,CAAE,SAAAH,EAAU,IAAAC,EAAK,KAAAC,CAAK,IAC3B,MAAMJ,EAAcC,EAAQ,CAAE,SAAAC,EAAU,IAAAC,EAAK,KAAAC,CAAK,CAAC,EAG9D,OAAQ,MAAO,CAAE,SAAAF,EAAU,UAAAM,EAAW,KAAAJ,CAAK,IAAM,CAC7C,IAAMC,EAAY,eAAY,EAAAC,YAAU,YAASJ,CAAQ,EAAG,CACxD,WAAY,EAChB,CAAC,IAEK,CAAE,MAAAK,EAAO,UAAWQ,CAAe,EAAQ,WAAS,CACtD,UAAAV,EACA,QAAQD,GAAA,YAAAA,EAAM,SAAU,CAAC,IAAI,EAC7B,UAAW,CACP,MAAO,CACH,KAAM,eAAY,EAAAE,YAAU,YAASJ,CAAQ,EAAG,CAC5C,WAAY,EAChB,CAAC,SACD,SAAU,GACV,MAAO,CACH,IAAC,EAAAI,YAAU,YAASJ,CAAQ,CAAC,CAAC,EAAGM,CACrC,CACJ,CACJ,CACJ,CAAC,EAOD,MAAO,CACH,MANa,MAAMP,EAAO,QAC1BM,EACAQ,CACJ,GAGmBV,CAAS,CAC5B,CACJ,EAEA,WAAY,MAAO,CAAE,SAAAH,EAAU,UAAAM,EAAW,KAAAJ,CAAK,IAAM,CACjD,IAAMC,EAAY,gBAAa,EAAAC,SAAUJ,EAAU,CAC/C,WAAY,EAChB,CAAC,IAEK,CAAE,MAAAK,EAAO,UAAWQ,CAAe,EAAQ,WAAS,CACtD,UAAAV,EACA,QAAQD,GAAA,YAAAA,EAAM,SAAU,CAAC,IAAI,EAC7B,UAAW,CACP,MAAO,CACH,KAAM,gBAAa,EAAAE,SAAUJ,EAAU,CACnC,WAAY,EAChB,CAAC,SACD,SAAU,GACV,MAAO,CACH,IAAC,EAAAI,SAAUJ,CAAQ,CAAC,EAAGM,CAC3B,CACJ,CACJ,CACJ,CAAC,EAOD,MAAO,CACH,MANa,MAAMP,EAAO,QAC1BM,EACAQ,CACJ,GAGmBV,CAAS,CAC5B,CACJ,EACA,OAAQ,MAAO,CAAE,SAAAH,EAAU,GAAAiB,EAAI,UAAAX,EAAW,KAAAJ,CAAK,IAAM,CACjD,IAAMC,EAAY,eAAY,EAAAC,YAAU,YAASJ,CAAQ,EAAG,CACxD,WAAY,EAChB,CAAC,IAEK,CAAE,MAAAK,EAAO,UAAWQ,CAAe,EAAQ,WAAS,CACtD,UAAAV,EACA,QAAQD,GAAA,YAAAA,EAAM,SAAU,CAAC,IAAI,EAC7B,UAAW,CACP,MAAO,CACH,KAAM,eAAY,EAAAE,YAAU,YAASJ,CAAQ,EAAG,CAC5C,WAAY,EAChB,CAAC,SACD,SAAU,GACV,MAAO,CACH,GAAAiB,EACA,OAAQX,CACZ,CACJ,CACJ,CACJ,CAAC,EAOD,MAAO,CACH,MANa,MAAMP,EAAO,QAC1BM,EACAQ,CACJ,GAGmBV,CAAS,CAC5B,CACJ,EAEA,WAAY,MAAO,CAAE,SAAAH,EAAU,IAAAC,EAAK,UAAAK,EAAW,KAAAJ,CAAK,IAAM,CACtD,IAAMC,EAAY,gBAAa,EAAAC,SAAUJ,EAAU,CAC/C,WAAY,EAChB,CAAC,IAEK,CAAE,MAAAK,EAAO,UAAWQ,CAAe,EAAQ,WAAS,CACtD,UAAAV,EACA,OAAQ,CAAC,cAAc,EACvB,UAAW,CACP,MAAO,CACH,KAAM,gBAAa,EAAAC,SAAUJ,EAAU,CACnC,WAAY,EAChB,CAAC,SACD,SAAU,GACV,MAAO,CACH,OAAQ,CACJ,GAAI,CAAE,GAAIC,CAAI,CAClB,EACA,OAAQK,CACZ,CACJ,CACJ,CACJ,CAAC,EAED,aAAMP,EAAO,QAAoBM,EAAOQ,CAAc,EAE/C,MAAMf,EAAcC,EAAQ,CAAE,SAAAC,EAAU,IAAAC,EAAK,KAAAC,CAAK,CAAC,CAC9D,EACA,OAAQ,MAAO,CAAE,SAAAF,EAAU,GAAAiB,EAAI,KAAAf,CAAK,IAAM,CACtC,IAAMC,KAAY,EAAAC,YAAU,YAASJ,CAAQ,CAAC,EAExC,CAAE,MAAAK,EAAO,UAAAC,CAAU,EAAQ,QAAM,CACnC,UAAAH,EACA,QAAQD,GAAA,YAAAA,EAAM,SAAU,CAAC,IAAI,EAC7B,UAAW,CACP,GAAI,CACA,KAAM,KACN,SAAU,GACV,MAAOe,CACX,CACJ,CACJ,CAAC,EAID,MAAO,CACH,MAHa,MAAMlB,EAAO,QAAoBM,EAAOC,CAAS,GAG/CH,CAAS,CAC5B,CACJ,EACA,UAAW,MAAO,CAAE,SAAAH,EAAU,GAAAiB,EAAI,KAAAf,CAAK,IAAM,CACzC,IAAMC,EAAY,eAAY,EAAAC,YAAU,YAASJ,CAAQ,EAAG,CACxD,WAAY,EAChB,CAAC,IAEK,CAAE,MAAAK,EAAO,UAAAC,CAAU,EAAQ,WAAS,CACtC,UAAAH,EACA,QAAQD,GAAA,YAAAA,EAAM,SAAU,CAAC,IAAI,EAC7B,UAAW,CACP,MAAO,CACH,KAAM,eAAY,EAAAE,YAAU,YAASJ,CAAQ,EAAG,CAC5C,WAAY,EAChB,CAAC,SACD,SAAU,GACV,MAAO,CACH,GAAAiB,CACJ,CACJ,CACJ,CACJ,CAAC,EAID,MAAO,CACH,MAHa,MAAMlB,EAAO,QAAoBM,EAAOC,CAAS,GAG/CH,CAAS,CAC5B,CACJ,EACA,WAAY,MAAO,CAAE,SAAAH,EAAU,IAAAC,EAAK,KAAAC,CAAK,IAAM,CAC3C,IAAMC,EAAY,gBAAa,EAAAC,SAAUJ,EAAU,CAC/C,WAAY,EAChB,CAAC,IAEK,CAAE,MAAAK,EAAO,UAAAC,CAAU,EAAQ,WAAS,CACtC,UAAAH,EACA,OAAQ,CAAC,cAAc,EACvB,UAAW,CACP,MAAO,CACH,KAAM,gBAAa,EAAAC,SAAUJ,EAAU,CACnC,WAAY,EAChB,CAAC,SACD,SAAU,GACV,MAAO,CACH,OAAQ,CACJ,GAAI,CAAE,GAAIC,CAAI,CAClB,CACJ,CACJ,CACJ,CACJ,CAAC,EAED,aAAMF,EAAO,QAAoBM,EAAOC,CAAS,EAE1C,CACH,KAAM,CAAC,CACX,CACJ,EACA,UAAW,IAAM,CACb,MAAM,MACF,uDACJ,CACJ,EACA,OAAQ,MAAO,CAAE,IAAAY,EAAK,OAAAC,EAAQ,QAAAC,EAAS,KAAAlB,CAAK,IAAM,CAM9C,GALIgB,GACAnB,EAAO,YAAYmB,CAAG,EAE1BnB,EAAO,WAAWqB,CAAO,EAErBlB,GAAA,MAAAA,EAAM,SAMN,MAAO,CAAE,KALQ,MAAMH,EAAO,QAC1BG,EAAK,SACLA,EAAK,SACT,CAEwB,EAG5B,GAAIA,EACA,GAAIA,EAAK,UACL,GAAIiB,IAAW,MAAO,CAClB,GAAM,CAAE,MAAAd,EAAO,UAAAC,CAAU,EAAQ,QAAM,CACnC,UAAWJ,EAAK,UAChB,OAAQA,EAAK,OACb,UAAWA,EAAK,SACpB,CAAC,EAOD,MAAO,CACH,MANa,MAAMH,EAAO,QAC1BM,EACAC,CACJ,GAGmBJ,EAAK,SAAS,CACjC,MACG,CACH,GAAM,CAAE,MAAAG,EAAO,UAAAC,CAAU,EAAQ,WAAS,CACtC,UAAWJ,EAAK,UAChB,OAAQA,EAAK,OACb,UAAWA,EAAK,SACpB,CAAC,EAOD,MAAO,CACH,MANa,MAAMH,EAAO,QAC1BM,EACAC,CACJ,GAGmBJ,EAAK,SAAS,CACjC,MAGJ,OAAM,MAAM,kCAAkC,MAGlD,OAAM,MACF,sEACJ,CAER,CACJ,GAGGmB,EAAQd,GE5Wf,IAAAe,GAAiC,0BCHjC,IAAAC,EAA8B,iCAC9BC,EAAsC,gCACtCC,EAAwD,kBACxDC,EAMO,oBACPC,EAAuC,iCAUvCC,EAWO,gBAEPC,EAAwC,sBAwnBxCC,GAAuC,qBACvCH,EAAuC,iCAtmBvC,IAAMI,EAAkBC,GAA+D,CACrF,IAAIC,EAAmC,CAAA,EACvC,OAAID,IAEC,OAAO,QAAY,KAAeA,aAAmB,SACrDE,GAAyB,WAAWF,aAA8B,UAEnEC,KAAW,gCAA6BD,CAAO,EACtC,MAAM,QAAQA,CAAO,EAC9BA,EAAQ,QAAQ,CAAC,CAACG,EAAMC,CAAK,IAAK,CAC5BD,GAAQC,IAAU,SACpBH,EAASE,CAAI,EAAIC,EAErB,CAAC,EAEDH,EAAWD,GAIRC,CACT,EAKMI,EAAcC,GAAwBA,EAAI,QAAQ,sBAAuB,GAAG,EAAE,KAAI,EAqBlFC,GAA2CC,GAA+C,CAC9F,GAAI,CAAC,MAAM,QAAQA,EAAO,KAAK,EAAG,CAChC,IAAMC,EAAUD,EACVE,EAAmB,CAAC,SAAS,mBAAmBL,EAAWI,EAAQ,KAAK,CAAC,GAAG,EAElF,OAAID,EAAO,WACTE,EAAO,KAAK,aAAa,mBAAmBD,EAAQ,eAAe,UAAUA,EAAQ,SAAS,CAAC,GAAG,EAGhGA,EAAQ,eACVC,EAAO,KAAK,iBAAiB,mBAAmBD,EAAQ,aAAa,GAAG,EAGnEC,EAAO,KAAK,GAAG,EAGxB,GAAI,OAAOF,EAAO,UAAc,KAAe,CAAC,MAAM,QAAQA,EAAO,SAAS,EAC5E,MAAM,IAAI,MAAM,8DAA8D,EAIhF,IAAMC,EAAUD,EACVG,EAAUH,EAAO,MAAM,OAC3B,CAACI,EAAKC,EAAcC,KAClBF,EAAI,KAAK,CACP,MAAOP,EAAWQ,CAAY,EAC9B,UAAWJ,EAAQ,UAAYA,EAAQ,eAAe,UAAUA,EAAQ,UAAUK,CAAK,CAAC,EAAI,OAC7F,EACMF,GAET,CAAA,CAAE,EAGJ,MAAO,SAAS,mBAAmBH,EAAQ,eAAe,UAAUE,CAAO,CAAC,GAC9E,EAeMI,GACHC,GACD,MAA4BR,GAAgC,CAC1D,GAAM,CAAE,IAAAS,EAAK,MAAAC,EAAO,UAAAC,EAAW,cAAAC,EAAe,MAAAC,EAAO,aAAAC,EAAc,WAAAC,CAAU,EAAKf,EAE5ER,EAAU,CAAE,GAAGQ,EAAO,OAAO,EAC/BgB,EAAc,GACdC,EAEAT,IAAW,QACbS,KAAO,EAAAC,SAAkBR,EAAOC,EAAWC,EAAeE,EAAa,cAAc,EACjF,OAAOG,GAAS,WAElBzB,EAAQ,cAAc,EAAI,qBAI5BwB,EAAcjB,GAAsB,CAClC,MAAAW,EACA,UAAAC,EACA,cAAAC,EACA,eAAgBE,EAAa,gBAAkB,wBAChD,EAGH,IAAMK,EAAwB,CAC5B,OAAAX,EACA,QAAAhB,EACA,KAAAyB,EACA,GAAGH,GAGDM,EAAcX,EACdY,EAAeF,EACnB,GAAIJ,EAAY,CACd,IAAMO,EAAS,MAAM,QAAQ,QAAQP,EAAW,CAAE,GAAGI,EAAM,IAAAV,EAAK,cAAAG,EAAe,UAAAD,CAAS,CAAE,CAAC,EACrF,CAAE,IAAKY,EAAQ,GAAGC,CAAO,EAAKF,EACpCF,EAAcG,EACdF,EAAeG,EAEjB,OAAIR,IACFI,EAAc,GAAGA,KAAeJ,KAE3B,MAAMH,EAAMO,EAAaC,CAAY,CAC9C,EAKWI,EAAP,KAAoB,CACxB,YAAoBhB,EAA6BiB,EAA+B,CAAA,EAAE,CAA9D,KAAA,IAAAjB,EAA6B,KAAA,cAAAiB,EAKjD,KAAA,WAA+B,SAC1BC,IACqB,CACxB,GAAM,CAACC,EAAgBjB,EAAWkB,CAAc,EAAIF,EAC9CG,KAAoB,uBAAuBF,EAAgBjB,EAAWkB,CAAc,EAEpF,CACJ,QAAArC,EACA,MAAAqB,EAAQ,EAAAkB,QACR,OAAAvB,EAAS,OACT,kBAAAwB,EACA,mBAAAC,EACA,GAAGnB,CAAY,EACb,KAAK,cACH,CAAE,IAAAL,CAAG,EAAK,KACZqB,EAAkB,SAAW,SAC/BhB,EAAa,OAASgB,EAAkB,QAG1C,GAAM,CAAE,cAAAlB,CAAa,KAAK,0BAAuBkB,EAAkB,KAAK,EAExE,OAAOI,EAAkB,CACvB,IAAAzB,EACA,MAAOqB,EAAkB,MACzB,UAAWA,EAAkB,UAC7B,QAAS,CACP,GAAGvC,EAAe4C,EAAe3C,CAAO,CAAC,EACzC,GAAGD,EAAeuC,EAAkB,cAAc,GAEpD,cAAAlB,EACA,MAAAC,EACA,OAAAL,EACA,aAAAM,EACA,WAAYkB,EACb,EACE,KAAMI,IACDH,GACFA,EAAmBG,CAAQ,EAEtBA,EACR,EACA,MAAOC,GAAS,CACf,MAAIJ,GACFA,EAAmBI,CAAK,EAEpBA,CACR,CAAC,CACL,CApDqF,CA8DrF,MAAM,QACJC,KACGC,EAA6D,CAEhE,GAAM,CAAC5B,EAAWkB,CAAc,EAAIU,EAC9BC,KAAiB,oBAAiBF,EAAmB3B,EAAWkB,CAAc,EAE9E,CACJ,QAAArC,EACA,MAAAqB,EAAQ,EAAAkB,QACR,OAAAvB,EAAS,OACT,kBAAAwB,EACA,mBAAAC,EACA,GAAGnB,CAAY,EACb,KAAK,cACH,CAAE,IAAAL,CAAG,EAAK,KACZ+B,EAAe,SAAW,SAC5B1B,EAAa,OAAS0B,EAAe,QAGvC,GAAM,CAAE,MAAA9B,EAAO,cAAAE,CAAa,KAAK,0BAAuB4B,EAAe,QAAQ,EAE/E,OAAON,EAAe,CACpB,IAAAzB,EACA,MAAAC,EACA,UAAW8B,EAAe,UAC1B,QAAS,CACP,GAAGjD,EAAe4C,EAAe3C,CAAO,CAAC,EACzC,GAAGD,EAAeiD,EAAe,cAAc,GAEjD,cAAA5B,EACA,MAAAC,EACA,OAAAL,EACA,aAAAM,EACA,WAAYkB,EACb,EACE,KAAMI,IACDH,GACFA,EAAmBG,CAAQ,EAEtBA,EAAS,KACjB,EACA,MAAOC,GAAS,CACf,MAAIJ,GACFA,EAAmBI,CAAK,EAEpBA,CACR,CAAC,CACL,CAUA,cACEI,EACAZ,EAA2C,CAE3C,IAAMa,KAAsB,yBAAyBD,EAAoBZ,CAAc,EACjF,CAAE,QAAArC,EAAS,GAAGsB,CAAY,EAAK,KAAK,cAEtC4B,EAAoB,SAAW,SACjC5B,EAAa,OAAS4B,EAAoB,QAG5C,IAAMC,EAAUD,EAAoB,UAAU,IAC5C,CAAC,CAAE,SAAAE,CAAQ,OAAO,0BAAuBA,CAAQ,EAAE,KAAK,EAEpDjC,EAAY+B,EAAoB,UAAU,IAAI,CAAC,CAAE,UAAA/B,CAAS,IAAOA,CAAS,EAEhF,OAAOuB,EAAe,CACpB,IAAK,KAAK,IACV,MAAOS,EAEP,UAAAhC,EACA,QAAS,CACP,GAAGpB,EAAe4C,EAAe3C,CAAO,CAAC,EACzC,GAAGD,EAAemD,EAAoB,cAAc,GAEtD,cAAe,OACf,MAAO,KAAK,cAAc,OAAS,EAAAX,QACnC,OAAQ,KAAK,cAAc,QAAU,OACrC,aAAAjB,EACA,WAAY,KAAK,cAAc,kBAChC,EACE,KAAMsB,IACD,KAAK,cAAc,oBACrB,KAAK,cAAc,mBAAmBA,CAAQ,EAEzCA,EAAS,KACjB,EACA,MAAOC,GAAS,CACf,MAAI,KAAK,cAAc,oBACrB,KAAK,cAAc,mBAAmBA,CAAK,EAEvCA,CACR,CAAC,CACL,CAEA,WAAW7C,EAAmC,CAC5C,YAAK,cAAc,QAAUA,EACtB,IACT,CAKA,UAAUqD,EAAajD,EAAa,CAClC,GAAM,CAAE,QAAAJ,CAAO,EAAK,KAAK,cAEzB,OAAIA,EAGFA,EAAQqD,CAAG,EAAIjD,EAEf,KAAK,cAAc,QAAU,CAAE,CAACiD,CAAG,EAAGjD,CAAK,EAGtC,IACT,CAKA,YAAYA,EAAa,CACvB,YAAK,IAAMA,EACJ,IACT,GAGIsC,EAAc,MAAqDlC,GAU9C,CACzB,GAAM,CAAE,MAAAU,EAAO,UAAAC,EAAW,aAAAG,CAAY,EAAKd,EACrC8C,EAAUvC,MAAwB,aAAUP,EAAO,QAAU,MAAM,CAAC,EACpE+C,EAAkB,MAAM,QAAQ/C,EAAO,KAAK,EAC5CoC,EAAW,MAAMU,EAAQ9C,CAAM,EAC/BsB,EAAS,MAAM0B,GAAUZ,EAAUtB,EAAa,gBAAkB,uBAAqB,EAEvFmC,EAA2B,MAAM,QAAQ3B,CAAM,EACjD,CAACA,EAAO,KAAK,CAAC,CAAE,KAAA4B,CAAI,IAAO,CAACA,CAAI,EAChC,EAAQ5B,EAAO,KAEb6B,EACJ,MAAM,QAAQ7B,CAAM,GACpB,CAACA,EAAO,QACP,MAAM,QAAQA,EAAO,MAAM,GAAK,CAACA,EAAO,OAAO,QAChDR,EAAa,cAAgB,OAC7BA,EAAa,cAAgB,SAE/B,GAAIsB,EAAS,IAAMe,GAAiCF,EAA0B,CAE5E,GAAM,CAAE,OAAAG,EAAQ,GAAGC,CAAI,GAAK,MAAM,QAAQ/B,CAAM,EAAIA,GAC9C4B,EAAOpC,EAAa,cAAgB,SAAWuC,EAAO/B,EAI5D,MAAO,CACL,GAJmByB,EAAkB,CAAE,KAAAG,CAAI,EAAKA,EAKhD,QAASd,EAAS,QAClB,OAAQA,EAAS,YAEd,CACL,IAAMkB,EACJ,OAAOhC,GAAW,SACd,CACE,MAAOA,GAETA,EACN,MAAM,IAAI,cAER,CAAE,GAAGgC,EAAa,OAAQlB,EAAS,OAAQ,QAASA,EAAS,OAAO,EACpE,CAAE,MAAA1B,EAAO,UAAAC,CAAS,CAAE,EAG1B,EA2Ba4C,GAAyB,SACjC5B,IACqB,CACxB,GAAM,CAAC6B,EAAc9C,EAAO,GAAG6B,CAA0B,EAAIZ,EACvDa,KAAiB,+BAA+BgB,EAAc9C,EAAO,GAAG6B,CAA0B,EAExG,OADe,IAAId,EAAce,EAAe,GAAG,EACrC,WAAiB,CAC7B,GAAGA,EACJ,CACH,EA6CA,eAAsBiB,GACpBD,EAEAZ,KACGL,EAA6D,CAGhE,IAAMC,KAAiB,4BAA4BgB,EAAcZ,EAAU,GAAGL,CAA0B,EAExG,OADe,IAAId,EAAce,EAAe,GAAG,EACrC,QAAc,CAC1B,GAAGA,EACJ,CACH,CAoCO,IAAMkB,GAA+B,SAAU/B,IAA2B,CAC/E,IAAM3B,EAAS2D,GAA+BhC,CAAI,EAElD,OADe,IAAIF,EAAczB,EAAO,GAAG,EAC7B,cAAcA,CAAM,CACpC,EAkBM2D,GAAkChC,GAClCA,EAAK,SAAW,EACXA,EAAK,CAAC,EAEN,CACL,IAAKA,EAAK,CAAC,EACX,UAAWA,EAAK,CAAC,EACjB,eAAgBA,EAAK,CAAC,EACtB,OAAQ,QAOd,IAAMiC,GAAY,MAChBC,EACAC,IAME,CACF,IAAIC,EAQJ,OANAF,EAAS,QAAQ,QAAQ,CAACG,EAAOC,IAAO,CAClCA,EAAI,YAAW,IAAO,iBACxBF,EAAcC,EAElB,CAAC,EAGCD,IACCA,EAAY,YAAW,EAAG,WAAW,kBAAkB,GACtDA,EAAY,YAAW,EAAG,WAAW,0BAA0B,GAC/DA,EAAY,YAAW,EAAG,WAAW,mCAAmC,GAEnED,EAAe,MAAM,MAAMD,EAAS,KAAI,CAAE,EAE1CA,EAAS,KAAI,CAExB,EAEMK,EAAqBF,GAClB,OAAOA,GAAU,WAAcA,EAAiB,EAAKA,EAgBjDG,GAAM,CAACC,KAAiCC,IAC5CD,EAAO,OACZ,CAACE,EAAaC,EAAOC,IAAU,GAAGF,IAAcC,IAAQC,KAASH,EAAYA,EAAUG,CAAK,EAAI,KAChG,EAAE,ED5nBN,IAAAC,GAA2B,mBEjB3B,IAAMC,EAAuB,CACzBC,EACA,CAAE,SAAAC,EAAU,OAAAC,CAAO,EACnBC,IACC,CACD,IAAMC,EAAoB,CACtB,QAASC,EACT,QAASC,EACT,QAASC,CACb,EAEM,CAAE,SAAAC,EAAU,KAAAC,EAAM,QAAAC,EAAS,iBAAAC,EAAkB,GAAAC,EAAI,IAAAC,CAAI,EAAIX,GAAU,CAAC,EAEpEY,EAAYV,EAAaD,CAAI,EAE7B,CAAE,UAAAY,EAAW,MAAAC,EAAO,UAAAC,CAAU,EAAIH,EAAU,CAC9C,IAAAD,EACA,GAAAD,EACA,SAAAJ,EACA,QAAAE,EACA,KAAAD,EACA,iBAAAE,CACJ,CAAC,EAEKO,EAAUC,GAAiB,CAC7BlB,EAASkB,EAAQ,KAAKJ,CAAS,CAAC,CACpC,EAWA,OAToBf,EAAO,UACvB,CAAE,MAAAgB,EAAO,UAAAC,CAAU,EACnB,CACI,KAAMC,EACN,MAAO,QAAQ,MACf,SAAU,IAAM,IACpB,CACJ,CAGJ,EAEaE,GAAgBpB,IAClB,CACH,UAAU,CAAE,SAAAC,EAAU,OAAAC,CAAO,EAAG,CAC5B,GAAM,CAAE,SAAAM,EAAU,KAAAC,EAAM,QAAAC,EAAS,iBAAAC,EAAkB,GAAAC,EAAI,IAAAC,CAAI,EACvDX,GAAU,CAAC,EAEf,GAAI,CAACO,EACD,MAAM,IAAI,MACN,6EACJ,EAGJ,GAAI,CAACE,EACD,MAAM,IAAI,MACN,yFACJ,EAGJ,GAAI,CAACH,EACD,MAAM,IAAI,MACN,iFACJ,EAGJ,IAAMa,EAAsB,CAAC,EAE7B,IAAInB,GAAA,YAAAA,EAAQ,oBAAqB,UAAW,CACxC,IAAMoB,EAAqBvB,EACvBC,EACA,CAAE,SAAAC,EAAU,OAAAC,CAAO,EACnB,SACJ,EAEMqB,EAAqBxB,EACvBC,EACA,CAAE,SAAAC,EAAU,OAAAC,CAAO,EACnB,SACJ,EAEMsB,EAAqBzB,EACvBC,EACA,CAAE,SAAAC,EAAU,OAAAC,CAAO,EACnB,SACJ,EAEAmB,EAAa,KAAKC,CAAkB,EACpCD,EAAa,KAAKE,CAAkB,EACpCF,EAAa,KAAKG,CAAkB,EAGxC,IAAItB,GAAA,YAAAA,EAAQ,oBAAqB,SAAU,CACvC,IAAMqB,EAAqBxB,EACvBC,EACA,CAAE,SAAAC,EAAU,OAAAC,CAAO,EACnB,SACJ,EAEAmB,EAAa,KAAKE,CAAkB,EAOxC,MAJoB,IAAM,CACtBF,EAAa,QAASI,GAAgBA,EAAY,CAAC,CACvD,CAGJ,EACA,YAAYA,EAAa,CACrBA,EAAY,CAChB,CACJ,GFpHJ,IAAOC,GAAQC","names":["import_camelcase","gql","import_pluralize","import_camelcase","gql","import_pluralize","import_set","operatorMap","operatorMapper","operator","value","generateFilters","filters","result","f","filter","set","generateSorting","sorters","sorter","generatePaging","pagination","generateCreatedSubscription","resource","meta","operation","camelcase","queryVariables","query","variables","generateUpdatedSubscription","generateDeletedSubscription","field","handleGetMany","client","resource","ids","meta","operation","camelcase","query","variables","dataProvider","pagination","sorters","filters","paging","generatePaging","queryVariables","generateFilters","generateSorting","response","id","url","method","headers","dataProvider_default","qqlQueryBuilder","import_createRequestBody","import_defaultJsonSerializer","import_helpers","import_parseArgs","import_resolveRequestDocument","import_types","CrossFetch","import_graphql_ws","resolveHeaders","headers","oHeaders","CrossFetch","name","value","cleanQuery","str","buildRequestConfig","params","params_","search","payload","acc","currentQuery","index","createHttpMethodFetcher","method","url","query","variables","operationName","fetch","fetchOptions","middleware","queryParams","body","createRequestBody","init","urlResolved","initResolved","result","urlNew","initNew","GraphQLClient","requestConfig","args","queryOrOptions","requestHeaders","rawRequestOptions","crossFetch","requestMiddleware","responseMiddleware","makeRequest","callOrIdentity","response","error","documentOrOptions","variablesAndRequestHeaders","requestOptions","documentsOrOptions","batchRequestOptions","queries","document","key","fetcher","isBatchingQuery","getResult","successfullyReceivedData","data","successfullyPassedErrorPolicy","errors","rest","errorResult","rawRequest","urlOrOptions","request","batchRequests","parseBatchRequestsArgsExtended","getResult","response","jsonSerializer","contentType","value","key","callOrIdentity","gql","chunks","variables","accumulator","chunk","index","graphqlWS","generateSubscription","client","callback","params","type","generatorMap","generateCreatedSubscription","generateUpdatedSubscription","generateDeletedSubscription","resource","meta","filters","subscriptionType","id","ids","generator","operation","query","variables","onNext","payload","liveProvider","unsubscribes","createdUnsubscribe","updatedUnsubscribe","deletedUnsubscribe","unsubscribe","src_default","dataProvider_default"]}